---
title: "class 13 RNA-Seq with DESeq2"
author: "Melanda Aboueid (PID: 17473102)"
format: pdf
toc: TRUE
---

## Background
Today we will preform an RNAseq analysis of the effects of a common stertoid on airway cells.

In perticular, dexamethasone (herafter just called "dex") on diffrent airway smooth muscle cell lines (ASM cells).

## Data Import 

We need two difftrent inputs:

- **countData**: With genes in rows and experiments in colums
- **colData**: meta data that describes the colums in countData

```{r}
counts <- read.csv("airway_scaledcounts.csv", row.names=1)
metadata <- read.csv("airway_metadata.csv")
```


```{r}
head(counts)
```
```{r}
metadata
```

>Q1. How many genes are in this dataset?

```{r}
nrow(counts)
```


> Q2. How many ‘control’ cell lines do we have?

```{r}
sum (metadata$dex == "control")
```
```{r}
table(metadata$dex)
```

## differential gene expression

We have 4 replicate drug treated and control (no drug) columns/experiments in out `counts` object.

we want one "mean" value for each gene (rows) in "treated" (drug) and one mean value for each gene in "control" cols.

Step 1:Find all "control" colums in `counts`

```{r}
control.inds <- metadata$dex == "control"
```

Step 2: Extact these columns to a new object called `control.counts`

```{r}
control.counts <- counts[ , control.inds]
```

Step 3: then calculate the mean value for each gene

```{r}
control.mean <- rowMeans(control.counts)
```

> Q3. How would you make the above code in either approach more robust? Is there a function that could help here?

We could make the code more robust by using the rowMeans() function instead of manually summing and dividing so we don’t hard-code /4. 

> Q4. Follow the same procedure for the treated samples (i.e. calculate the mean per gene across drug treated samples and assign to a labeled vector called treated.mean)

Now do the same thing for the "treated" colu,ns/experiments... 


Step 1:Find all "treated" colums in `counts`

```{r}
treated.inds <- metadata$dex == "treated"
```

Step 2: Extact these columns to a new object called `treated.counts`

```{r}
treated.counts <- counts[ , treated.inds]
```

Step 3: then calculate the mean value for each gene

```{r}
treated.mean <- rowMeans(treated.counts)
```


put these together for easy bookkeeping as `meancounts`

```{r}
meancounts <- data.frame(control.mean, treated.mean)
```

> Q5 (a). Create a scatter plot showing the mean of the treated samples against the mean of the control samples. Your plot should look something like the following.

explicitly doing plot(control.mean, treated.mean) makes it crystal-clear you plotted “treated vs control,” but plot(meancounts) is still fine.

A quick plot

```{r}
plot(meancounts)
```

> Q5 (b).You could also use the ggplot2 package to make this figure producing the plot below. What geom_?() function would you use for this plot? 

The geom used for this scatter plot is geom_point().

```{r}
library(ggplot2)

ggplot(meancounts, aes(x=control.mean, y=treated.mean)) +
  geom_point()
```


> Q6. Try plotting both axes on a log scale. What is the argument to plot() that allows you to do this?

Lets log trasfrom this count data

```{r}
plot(meancounts, log="xy")
```

**N.B.** We most oftern use log2 for this type of data so it makes the interpratation much more straightforward.


Treated/Control is oftern called "fold-chnage"

if there was no chnage we would have a log2-fc of zero:
```{r}
log2(10/10)
```
If we gad doule the amout of trascript around we would have a log2-fc of 1

```{r}
log2(20/10)
```
If we had half as much transcript around we would have a log2-fc of -1
```{r}
log2(5/10)
```

> Q. Claculate a log2 fold change value for all of our genes and add it as a new colum to our `meancouts` object.

```{r}
meancounts$log2f <- log2(meancounts$treated.mean / meancounts$control.mean)

head(meancounts)
```

```{r}
log2(40/10)
```
There are some "funky" log2fc values (NaN and -Inf) here that come about when ever we have 0 mean count values. Typically we would remove these genes from any further analysis - as we can't say anything about them if we have no data for them.

> Q7. What is the purpose of the arr.ind argument in the which() function call above? Why would we then take the first column of the output and need to call the unique() function?

arr.ind=TRUE returns row and column indices. unique() ensures each gene is removed only once.

```{r}
zero.vals <- which(meancounts[,1:2]==0, arr.ind=TRUE)
to.rm <- unique(zero.vals[,1])
mycounts <- meancounts[-to.rm,]
head(mycounts)
```
> Q8. Using the up.ind vector above can you determine how many up regulated genes we have at the greater than 2 fc level? 

250

```{r}
up.ind <- mycounts$log2f > 2
sum(up.ind)
```

> Q9. Using the down.ind vector above can you determine how many down regulated genes we have at the greater than 2 fc level? 

367

```{r}
down.ind <- mycounts$log2f < -2
sum(down.ind)
```

> Q10. Do you trust these results? Why or why not?

No, this method is not reliable because it ignores sequencing depth and variability. DESeq2 provides proper statistical testing.


## DESeq analysis 

lets do this analysis with an estimate of ststistical significance using the **DESeq2** package 

```{r}
library(DESeq2)
```

DESeq (lime many bioconductor packages) want it's input data ina very spesific way. 

```{r}
dds <- DESeqDataSetFromMatrix(countData = counts, 
                       colData = metadata,
                       design = ~dex)
```


## Principal Component Analysis (PCA)

```{r}
vsd <- vst(dds, blind = FALSE)
plotPCA(vsd, intgroup = c("dex"))
```

```{r}
pcaData <- plotPCA(vsd, intgroup=c("dex"), returnData=TRUE)
head(pcaData)
```
 
 # Calculate percent variance per PC for the plot axis labels

```{r}
percentVar <- round(100 * attr(pcaData, "percentVar"))

```

```{r}
ggplot(pcaData) +
  aes(x = PC1, y = PC2, color = dex) +
  geom_point(size =3) +
  xlab(paste0("PC1: ", percentVar[1], "% variance")) +
  ylab(paste0("PC2: ", percentVar[2], "% variance")) +
  coord_fixed() +
  theme_bw()

```

## Run the DESeq analysis pipline

The main function `DESeq`

```{r}
dds <- DESeq(dds)
```

```{r}
res <- results(dds)
head(res)
```

```{r}
36000*0.05
```

## Volcano Plot 

This is a mian summary results figure from these kinds of studies. It is a plot of Log2-foldchnage vs (Adjusted) P-Value

```{r}
plot(res$log2FoldChange, res$padj)
```

Again this y-axis is highly needs log tramsforming 

```{r}
plot(res$log2FoldChange, log(res$padj))
```

Again this y-axis is highly needs log tramsforming and we can flip the y-axis with a minus sign so it looks like it 

```{r}
plot(res$log2FoldChange, -log(res$padj))
abline(v=-2, col="red")
abline(v=+2, col="red")
abline(h=-log(0.05), col="red")
```

## Setup our custom point color vector 

Start with default nase color "gray"

```{r}
mycols <- rep("gray", nrow(res))
mycols[ abs(res$log2FoldChange) > 2 ]  <- "red" 

inds <- (res$padj < 0.01) & (abs(res$log2FoldChange) > 2 )
mycols[ inds ] <- "blue"

# Volcano plot with custom colors 
plot( res$log2FoldChange,  -log(res$padj), 
 col=mycols, ylab="-Log(P-value)", xlab="Log2(FoldChange)" )

# Cut-off lines
abline(v=c(-2,2), col="gray", lty=2)
abline(h=-log(0.1), col="gray", lty=2)
```

For even more customization you might find the EnhancedVolcano bioconductor package useful (Note. It uses ggplot under the hood):




> Q. Make a presentation quality ggplot version of this plot. Include clear axis labels, a clean theme, your custom colors, cut-off line ans a plot title. 

```{r}
library(ggplot2)

ggplot(res) + 
  aes(log2FoldChange,
      -log(padj)) +
  geom_point(colour = mycols)
labs(x="Log2 Fold-change",
     y="-log Adjusted p-value") +
  geom_vline(xintercept = c(-2,2)) +
  geom_hline(yintercept = -log(0.05)) + 
  theme_bw()

```

## Save our results 


##  Adding annotation data

We need to add missing annotation data to our main res results object. this indicated common gene "symbol"

```{r}
head(res)
```
We will used R and bioconductor to do this "ID mapping"

```{r}
library("AnnotationDbi")
library("org.Hs.eg.db")
```

Lets see what databases we can use for translocation/mapping....

```{r}
columns(org.Hs.eg.db)
```


We can use the `mapIds()` function now to "translate" between any of these databases

> Q11. Run the mapIds() function two more times to add the Entrez ID and UniProt accession and GENENAME as new columns called res$entrez, res$uniprot and res$genename.

The mapIds() function was used to add Entrez IDs, UniProt accessions, and gene names to the DESeq2 results table.

```{r}
res$symbol <- mapIds(org.Hs.eg.db,
                     keys=row.names(res), # Our genenames
                     keytype="ENSEMBL",        # The format of our genenames
                     column="SYMBOL")          # The new format we want to add
  
```

```{r}
head(res)
```
> Q. Also add "ENTREZID", "GENENAME" IDs to our `res` object 

```{r}
res$entrez <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     keytype="ENSEMBL",
                     column="ENTREZID")


res$genename <- mapIds(org.Hs.eg.db,
                       keys=row.names(res),
                       keytype="ENSEMBL",
                       column="GENENAME")
```

You can arrange and view the results by the adjusted p-value

```{r}
ord <- order( res$padj )
#View(res[ord,])
head(res[ord,])

```
## Save annotated results to a CSV file 

```{r}
write.csv(res, file = "results_annotated.csv")
```

## Volcano plot 

```{r}
library(EnhancedVolcano)
```

```{r}
x <- as.data.frame(res)

EnhancedVolcano(x,
    lab = x$symbol,
    x = 'log2FoldChange',
    y = 'pvalue')
```


## Pathway analysis 

What known biological pathways do our diffrently expressed genes overlap with (I.e. play role in?)

There is lots of bioconductor packages to do this type of analysis.

We will use one of the oldest called **gage** along with **pathview** to render nice pics of the pathays we find 

we can install these with the command `BiocManager::install( c("pathview", "gage", "gageData") )`

```{r, message=FALSE}
library(pathview)
library(gage)
library(gageData)
```


have a wee peak what is in `gageData`

```{r}
data(kegg.sets.hs)
head(kegg.sets.hs, 2)
```
The main `gage()` function that does the work wants a simple vector as input. 

```{r}
foldchanges <- res$log2FoldChange
names(foldchanges) <- res$symbol
head(foldchanges)
```

The KEGG database uses ENTREZ ids so we need to provide these in our input vector for **gage**

```{r}
names(foldchanges) <- res$entrez
```

```{r}
# Get the results
keggres = gage(foldchanges, gsets=kegg.sets.hs)
```

What is in the output object `keggress`

```{r}
attributes(keggres)
```
```{r}
# Look at the first three down (less) pathways
head(keggres$less, 3)
```

We can use the **pathview** function to render a figure of any of these pathways along with annotation for our DEGs.

Lets now ssee the hsa05310 Asthma pathway with our DEGs colored up:

```{r}
pathview(gene.data=foldchanges, pathway.id="hsa05310")
```

![](hsa05310.pathview.png)


> Q. can yo render and insert here the pathway figure for "Graft-versus-host disease" and "Type I diabetes"

> Q12. Can you do the same procedure as above to plot the pathview figures for the top 2 down-reguled pathways?

```{r}
pathview(gene.data=foldchanges, pathway.id="hsa05332")
```

![](hsa05332.pathview.png)


```{r}
pathview(gene.data=foldchanges, pathway.id="hsa04940")
```

![](hsa04940.pathview.png)

